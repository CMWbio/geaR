---
title: "An Introduction To geaR"
author:
- name: Christopher Ward
  affiliation: School of Biological Sciences, University of Adelaide
  email: christopher.ward@adelaide.edu.au
- name: Alastair Ludington
  affiliation: School of Biological Sciences, University of Adelaide
- name: James Breen
  affiliation: School of Biological Sciences, University of Adelaide
- name: Simon Baxter
  affiliation: School of BioScience, University of Melbourne

package: geaR
output: BiocStyle::html_document
---
  
```{r}
 knitr::opts_chunk$set(message = FALSE,warning = FALSE)
```
  
  
# Introduction
  
The package GDS evolutionary analysis in R or `geaR` is designed to aid with evolutionary and population genetic analysis across whole genome genotype data in the `GDS` format.  
Analysis can be carried out using classical approaches such as sliding windows, however the main strength of geaR is the ability to include only certain types of features in the analysis.
  
# Conversion of VCF to GDS
  
VCF files can be converted using the R package `SeqArray`
  
This command will convert the sample VCF file into GDS format  to disk keeping only the Genotype field using 2 threads.
  
  
```{r, eval = FALSE}
  library(SeqArray)
  
  packageDir <- system.file("extdata", package = "ngsReports")
  seqVCF2GDS(vcf.fn = paste0(packageDir, "/sampleVCF.vcf.gz"),
  parallel = 2, out.fn = paste0(packageDir, "/sampleVCF.gds"),
  fmt.import = c("GT"), storage.option = "ZIP_RA")
  
```
  
  
  
# Carrying out analysis on different window types

A common analysis type is to subdivide the genome into equally sized windows before analysis.
Below we will construct loci for four different window types.

1. Tiled window
2. Sliding window 
3. Tiled SNP windows
4. Sliding SNP windows

Windows of a given size can be generated by using the `windowMaker()` or `SnpWindowMaker()` functions. 
In order to do this, first the package is loaded and scaffold/contig length must be input. 
If scaffold information is not known the necessary `data.frame` can be made using the reference genome's fasta index (.fai)
  
## Set up scaffold/contig meta data
```{r}
library(geaR)
library(readr)
library(tibble)


fileDir <- system.file("extdata", package = "geaR")

file <- file.path(fileDir, "/sampleReferenceGenome.fa.fai")

df <- readr::read_tsv(file, col_names = FALSE)
x <- tibble::tibble(ID = df[[1]], length = df[[2]])


x

```

We can then use the contig/scaffold metadata to constructh loci for a tiled or sliding windowed analysis.
This will construct windows using scaffold positions, however the number of genotypes are likely to be different between windows due to missing data.
Windows can then be generated by setting arguments `windowSize` and `stepSize`. Optionally, `nCores` can also be set to split the jobs over parallel processors.

## Constructing tiled and sliding windows
```{r}

### generate 10kb tiled windows
loci <- windowMaker(x = x, windowSize = 10000, stepSize = 0)

loci

### generate 10kb windows sliding by 2kb
loci <- windowMaker(x = x, windowSize = 10000, stepSize = 2000)

loci
```

The R package also allows for windows to be constructed based on genotype position in the GDS ensuring the same number of genotypes in each window. 

This will require the GDS to be passed to the function so first we must open a connaection to the GDS using `seqOpen()` from the SeqArray package.

## Constructing tiled and sliding snp windows
```{r}

library(SeqArray)

# open pointer to GDS on disk
GDS <- seqOpen(paste0(fileDir, "/sampleVCF.gds"), allow.duplicate = TRUE) 

### generate windows with the same number of SNPs in each
loci <- snpWindowMaker(x = x, GDS = GDS, windowSize = 1000, stepSize = 0)

loci

### generate windows with the same number of SNPs in each
loci <- snpWindowMaker(x = x, GDS = GDS, windowSize = 1000, stepSize = 200)

```


As Analysis will be calculated across populations, we then define both which individuals to carry out analysis on and what populations they belong to. 
As an example we will do this arbitrarily by first pointing to the `GDS` file on disk and extracting the sample names as a vector.
The population data frame can then be constructed by dividing individuals into populaitons. We will do this arbitrarily with 2 individuals in 10 populations.


## Get samples from GDS then construct population metadata
```{r}

samples <- seqGetData(gdsfile = GDS, var.name = "sample.id")

pops <- tibble::tibble(Sample = samples[1:20], Population = rep(paste0("P", 1:10), each = 2))
head(pops)

```

# Carrying out an analysis

We will then begin constructing **cog** objects. Cogs form the backbone of an analysis in \code{geaR}. 
For this example we will carry out all analyses: Genetic diversity, Admixture, Loci output and Distance tree output 
Genetic diversity will calculate 

* pi: Neis nucleotide diversity
* dxy: Neis absolute genetic distance
* da: Nei's ancesteral distance
* dmin: minimum hamming distance between samples
* dmax: maximum hamming distance between samples 
* Fst: Nei (1982) \eqn{\gamma}st which estimates Fst 
* RNDmin: minimum Relative node depth (Requires a outgroup to be set)
* federRND: Relative Node Depth using Feder (2005) (Requites and outgroup)

Admixture will calculate 

* f4
* fd

Output Loci will write loci to fasta files in a supplied directory. 
Output Trees will write distance trees to newick files in a supplied directory 

## Calculate default statistics on window `GRanges`

```{r}

### Change this to your desired output directory
outDir <- "~/Desktop/setupGear/"

### general arguments for the analysis
argCog <- makeCog(analysisType = "args", ploidy = 2, nCores = 2, minSites = 0.01, pairwiseDeletion = TRUE, removeIndels = TRUE)

### set up diverstity analysis
divCog <- makeCog(analysisType = "diversityFULL", stats = "all")

### set up admixture cog
admixCog <- makeCog(analysisType = "admixture", threePop = list(),
                    fourPop = list(c("P1", "P2", "P3", "P10")))

### set up output loci cog
outloci <-  makeCog(analysisType = "outputLoci", outputDirectory = outDir, alleles = "seperate", removeIndels = TRUE)

### set up output tree cog
outTrees <-  makeCog(analysisType = "outputTrees", outputDirectory = outDir, alleles = "seperate", removeIndels = TRUE)
```




We will then use a list of cogs to build a \code{gear} object for the analysis


## Constructing the geaR object and rung the analysis
```{r}

gear10kb <- makeGear(loci, populations = pops, outgroup = "P10", cogs = list(argCog,admixCog, divCog,outloci,outTrees))

gear10kb <- analyzeGear(GDS, gear = gear10kb)

```

### retreive diversity stats
```{r}

gear10kb@DiversityStatsFULL

```

### retreive admixture stats
```{r}

gear10kb@AdmixtureStats
```

### retreive output directory for fasta files
```{r}

gear10kb@OutputLoci



```

### retreive output directory for tree files
```{r}
gear10kb@OutputTrees
```


# Constructing loci using a gff

Users may wish to investigate different features across the genome.
Below we will read in coding sequence from a gff file, select 4-fold degenerate codons, and finally incorperate this into our windows.

## Setting up loci for cds using a GDS
```{r}

cds <- makeFeatures(gffName = paste0(fileDir, "/sampleGFF.gff3"), feature = "gene:cds", longestIsoform = TRUE, geneIDField = "Name")

cds
```


We can then use the extracted coding sequence to generate a database containing codon positions and residues.
After this is generated we will then extract the 3rd position of 4-fold degenerate codons.
However, it is not sufficient just to filter the data as there may be variation within the test dataset causing an amino acid substitution.
To counter this we will validate the presence of 4-fold degenerate codons and return only those that match.


## Build codon database then validate 4-fold degenerate codons
```{r}
library(Biostrings)

### import genome and build the codon database
genome <- readDNAStringSet(paste0(fileDir, "/sampleReferenceGenome.fa"))
codons <- buildCodonDB(genome, exons = cds)

fourFold <- validate4FoldCodons(GDS, input = codons, pops = pops, nCores = 1)

codons
```

These ranges can then be incorperated into out 10kb tiled windows. 
In order to do this we use the `mergeLoci` function specifying our windows from before and the cds we just generated.

## Combining multiple loci 
```{r, eval = FALSE}

### additive merge the two loci 
cdsLoci <- mergeLoci(x = loci, y = cds, overlap = "+", nCores = 1)

```
