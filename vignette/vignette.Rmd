---
title: "An Introduction To geaR"
author:
- name: Christopher Ward
  affiliation: School of Biological Sciences, University of Adelaide
  email: christopher.ward@adelaide.edu.au
- name: Alastair Ludington
  affiliation: School of Biological Sciences, University of Adelaide
- name: Simon Baxter
  affiliation: School of Biological Sciences, University of Adelaide

package: geaR
output:
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{An Introduction To ngsReports}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

  ```{r}
knitr::opts_chunk$set(message = FALSE,warning = FALSE)
```


# Introduction

The package `geaR` is designed to aid with evolutionary and population genetic analysis across whole genome genotype data in the `GDS` format.  
Analysis can be carried out using classical approaches such as sliding windows, however the main strength of geaR is the ability to include only ceratin types of features in the analysis.

# Basic Usage

## Conversion of VCF to GDS

VCF files can be converted using the R package `SeqArray`

This command will convert the sample VCF file into GDS format  to disk keeping only the Genotype field using 2 threads.


```{r, eval = FALSE}
library(SeqArray)

seqVCF2GDS(vcf.fn = "../inst/extdata/sampleVCF.vcf.gz",
             parallel = 2, out.fn = "../inst/extdata/sampleVCF.gds",
           fmt.import = c("GT"), storage.option = "ZIP_RA")

```



## Windowed analysis

Windows of a given size can be generated by using the `windowMaker()` function. 
In order to do this, first the package is loaded and scaffold/contig length must be input. 
If scaffold information is not known the necessary `data.frame` can be made using the reference genome's fasta index (.fai)

#### Set up scaffold/contig meta data
```{r}
library(geaR)
library(readr)
library(tibble)


fileDir <- system.file("extdata", package = "geaR")

file <- file.path(fileDir, "../inst/extdata/sampleReferenceGenome.fa.fai")

df <- readr::read_tsv("../inst/extdata/sampleReferenceGenome.fa.fai", col_names = FALSE)
x <- tibble::tibble(ID = df[[1]], length = df[[2]])


x

```

Windows can then be generated by setting arguments `windowSize` and `stepSize`. Optionally, `nCores` can also be set to split the jobs over parallel processors.

Window ranges are stored as the `GRanges` class.

#### Construct windows
```{r}
windows <- windowMaker(x = x, windowSize = 10000, stepSize = 0)

windows
```


As Analysis will be calculated across populations, we must first define both which individuals to carry out analysis on and what populations they belong to. 


We will do this arbitrarily by first pointing to the `GDS` file on disk and extracting the sample names as a vector.

#### Get samples from GDS then construct population metadata
```{r}
library(SeqArray)

# open pointer to GDS on disk
GDS <- SeqArray::seqOpen("../inst/extdata/sampleVCF.gds", allow.duplicate = TRUE) 
  

samples <- SeqArray::seqGetData(gdsfile = GDS, var.name = "sample.id")

head(samples)

```

The population data frame can then be constructed by dividing individuals into populaitons. We will do this arbitrarily with 10 individuals in each of two populations.


```{r}

pops <- tibble::tibble(Sample = samples[1:20], Population = rep(c("P1", "P2"), each = 10))

pops
```



These windows can then be provided to the `getDiversityStats()` along with a `GDS` file, the populations `data.frame`, and a vector of analyses to carry out.

#### Calculate default statistics on window `GRanges`
```{r}

popGenDF_windowed <- getDiversityStats(GDS, loci = windows, minSites = 0.001, nCores = 2, stats = "all", pops = pops, pairwiseDeletion = TRUE)

popGenDF_windowed
```

## Summarizing results

As real world datasets can contain tens of thousands of windows, it may be useful to summarize statistics. 

This will provide:

* Mean value (calculated using a block-jackknife with a provided `blockSize`)
* Standard Error of the Jackknife blocks
* Z score for the blocks
* Median block value
* Minimum block value
* Maximum block value 


```{r}
# Summarize dxy and Fst over windows with a blockSize of 100 kb 

summarizeStats(x = popGenDF_windowed, blockSize = 100000, nCores = 2)

```


## Writing out data to fasta files for downstream analysis

Features, in this window sequence, can also be written to directory in fasta format

Alleles can be separated or combined into a consensus sequence for each individaual using the `alleles` argument

```{r, eval=FALSE}

# writing allelic windowed sequence data out to file
outputLociFasta(GDS, loci = windows, pops = pops, dir = "/path/to/directory/", 
                nCores = 1, ploidy = 2, alleles = "allelic", minSites = 0.001)

```

# Advanced Usage 

## Calculating statistics across features

Here we calculate population genetic statistics across genomic features as defined in a gff file.

Multiple types of features can be extracted from the GFF such as gene coding sequence.

#### Get coding sequence from GFF
```{r}

## Coding region extraction

coding <- getFeatures(gffName = "../inst/extdata/sampleGFF.gff3", feature = "gene:cds", nCores = 4, longestIsoform = TRUE)

coding[[1]]

```


This can then be passed to throught the `loci` argument in `getDiversityStats()` to calculate statistics across each genes coding region.

#### Calculate default statistics on coding regions
```{r}

popGenDF_coding <- getDiversityStats(GDS, coding, minSites = 0.0001, nCores = 2, stats = "all", pops = pops, pairwiseDeletion = TRUE)

popGenDF_coding
```


## Combining windows and features

Windows constructed using `windowMaker()` or multiple user defined ranges can be passed to `combineRanges()` along with features constructed using `getFeatures()` to combine windows with overlapping features.

Range combination can be done subtractively `overlap = "-"` or additavely `overlap = "+"`. Subtractive overlap will remove the features from the windows. Additive overlap will combine all features over windows.

#### Additive
```{r}

## Combine gene coding sequence within 10kb tiled windows

windowedCodingAdd <- combineRanges(window = windows, feature = coding, nCores = 2, overlap = "+")

windowedCodingAdd 
```

#### Subtractive
```{r}

## Combine gene coding sequence within 10kb tiled windows

windowedCodingSub <- combineRanges(window = windows, feature = coding, nCores = 2, overlap = "-")

windowedCodingSub 
```


Ranges generated can then be passed to `getDiversityStats()` to calculate statistics across windows. If Additive combination is carried out, all genes that overlapped with a window will be included in the `Gene` column.


```{r}

popGenDF_windowedCoding <- getDiversityStats(GDS, windowedCodingAdd, minSites = 0.0001, nCores = 2, stats = "all", pops = pops, pairwiseDeletion = TRUE)

popGenDF_windowedCoding
```

```{r}

popGenDF_windowedCodingSub <- getDiversityStats(GDS, windowedCodingSub, minSites = 0.0001, nCores = 2, stats = "all", pops = pops, pairwiseDeletion = TRUE)

popGenDF_windowedCodingSub
```


## Calculating Statistics utilizing codon positions

Statistics may want to be calculated for specific codon base positons or codon types.

First Codons are extracted from the reference genome and coding sequence built using `getFeatures()`.

```{r}

codonPos <- getCodonFeatures(genome = "../inst/extdata/sampleReferenceGenome.fa", exons = coding)

codonPos
```


This can be done using multiple filtering parameters. For Example:

###Only first and second base of each codon
```{r}
# Get only first and second codon positions
codonPos <- getCodonFeatures(genome = "../inst/extdata/sampleReferenceGenome.fa", exons = coding, position = c("first", "second"))
codonPos
```
###Only the third base of each codon 
```{r}
# Get only first and second codon positions
codonPos <- getCodonFeatures(genome = "../inst/extdata/sampleReferenceGenome.fa", exons = coding, position = c("third"))
codonPos
```
###All positions excluding the third base of 4-fold degenerate codons
```{r}
# Get only first and second codon positions
codonPos <- getCodonFeatures(genome = "../inst/extdata/sampleReferenceGenome.fa", exons = coding, fourFoldCodon = "exclude")
codonPos
```
###Only the third base of 4-fold degenerate codons
```{r}
# Get only first and second codon positions
codonPos <- getCodonFeatures(genome = "../inst/extdata/sampleReferenceGenome.fa", exons = coding, fourFoldCodon = "only")
codonPos
```


These can then be passed to `getDiversityStats()`

```{r}

popGenDF_4fold3rd <- getDiversityStats(GDS, codonPos, minSites = 0.0001, nCores = 2, stats = "all", pops = pops, pairwiseDeletion = TRUE)

popGenDF_4fold3rd
```




